
#version 450
#include source_lib

// These are the variables that we expect to receive from the vertex shader
layout(location = 2) in vec4 a_Color;
layout(location = 3) in vec3 pos;
layout(location = 4) in float camdis;

// This is what the fragment shader will output, usually just a pixel color
layout(location = 0) out vec4 frag_color;

vec4 fog_added(vec4 lit, float camdis, vec4 fog_color,float sensitive){
	float dist = (camdis/(pow(2.0,sensitive))); //bests sensitive = 7
	vec4 dismask = vec4(dist,dist,dist,1.0);
	return min( fog_color ,(fog_color*dismask)+ (lit*max(vec4(0.0),((1-dismask))) ) );

}



float fresnel(vec3 normal, vec3 LightDirection,vec3 CamDir,float intensity ){
	return pow(max(0,dot(normal,normalize(LightDirection+CamDir))),intensity);
}

vec4 specular(vec4 specularmap,vec3 normal, vec3 LightDirection,vec3 CamDir,float intensity ){
	vec4 a = vec4(fresnel(normal,LightDirection,CamDir,intensity));
	vec4 bb = a*specularmap;
	return clamp(vec4(0),vec4(1),bb);//fresnel_v4;
}

void main() {
	// Recalculate initial noise sampling position same as vertex shader
	vec3 noise_pos = (pos + vec3(_Offset.x, 0, _Offset.z)) / _Scale;

	// Calculate fbm, we don't care about the height just the derivatives here for the normal vector so the ` + _TerrainHeight - _Offset.y` drops off as it isn't relevant to the derivative
	vec3 n = _TerrainHeight * fbm(noise_pos.xz);

	// To more easily customize the color slope blending this is a separate normal vector with its horizontal gradients significantly reduced so the normal points upwards more
	vec3 slope_normal = normalize(vec3(-n.y, 1, -n.z) * vec3(_SlopeDamping, 1, _SlopeDamping));

	// Use the slope of the above normal to create the blend value between the two terrain colors
	float material_blend_factor = smoothstep(_SlopeRange.x, _SlopeRange.y, 1 - slope_normal.y);

	// Blend between the two terrain colors
	vec4 albedo = mix(_LowSlopeColor, _HighSlopeColor, vec4(material_blend_factor));
	vec4 albedo_mask = mix(vec4(0), vec4(1.0), vec4(material_blend_factor));

	// This is the actual surface normal vector
	vec3 normal = normalize(vec3(-n.y, 1, -n.z));

	// Lambertian diffuse, negative dot product values clamped off because negative light doesn't exist
	float ndotl = clamp(dot(_LightDirection, normal), 0, 1);

	// Direct light cares about the diffuse result, ambient light does not
	vec4 direct_light = albedo * ndotl;
	vec4 ambient_light = albedo * _AmbientLight;

	vec4 specular_v4 =specular(albedo_mask,normal,_LightDirection,_CamDir,50.0) *vec4(.5);


	// Combine lighting values, clip to prevent pixel values greater than 1 which would really really mess up the gamma correction below
	vec4 lit = clamp(specular_v4 + direct_light + ambient_light, vec4(0), vec4(1));



	
	vec4 fog_color = vec4(132/255.0,141/255.0,155/255.0,255/255.0);

	vec4 final  =  fog_added(lit,camdis,fog_color,7);

	// Convert from linear rgb to srgb for proper color output, ideally you'd do this as some final post processing effect because otherwise you will need to revert this gamma correction elsewhere
	frag_color = pow( final, vec4(2.2));
//vec4(fresnel)
}
